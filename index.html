<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Floating Thought Bubbles Connect</title>
    <style>
        /* CSS Variable for Scaling */
        :root {
            --scale-factor: 1;
            --vertical-gap: calc(8px * var(--scale-factor)); /* Reduced vertical gap */
            --button-width: calc(100px * var(--scale-factor)); /* Smaller button width */
            --input-width: calc(300px * var(--scale-factor)); /* Larger input box */
        }

        /* Basic styles for the body */
        html {
            height:100%;
            margin:0;
            padding:0;
        }

        body {
            height: 100%;
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            background: linear-gradient(135deg, #f5f7fa, #c3cfe2);
            font-family: 'Helvetica Neue', Arial, sans-serif;
            font-size: calc(16px * var(--scale-factor));
            position: relative;
        }

        /* Container to manage vertical spacing */
        #mainContainer {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--vertical-gap); /* Equal vertical spacing */
            padding-top: calc(10px * var(--scale-factor));
            box-sizing: border-box;
            z-index: 2; /* Added z-index to stack above #captureContainer */
        }

        /* Title at the top */
        #title {
            font-size: calc(24px * var(--scale-factor));
            font-weight: bold;
            color: #333;
            text-align: center;
            background-color: rgba(255, 255, 255, 0.9);
            padding: calc(10px * var(--scale-factor)) calc(20px * var(--scale-factor));
            border-radius: calc(5px * var(--scale-factor));
            box-shadow: 0 calc(2px * var(--scale-factor)) calc(5px * var(--scale-factor)) rgba(0,0,0,0.3);
            white-space: nowrap; /* Prevent wrapping */
        }

        /* Credits and version */
        #credits {
            font-size: calc(14px * var(--scale-factor));
            color: #333;
            text-align: center;
            background-color: rgba(255, 255, 255, 0.9);
            padding: calc(5px * var(--scale-factor)) calc(10px * var(--scale-factor));
            border-radius: calc(3px * var(--scale-factor));
            box-shadow: 0 calc(2px * var(--scale-factor)) calc(5px * var(--scale-factor)) rgba(0,0,0,0.3);
        }

        /* Style for the input area */
        #inputArea {
            position: relative;
            background-color: rgba(255, 255, 255, 0.9);
            padding: calc(10px * var(--scale-factor));
            border-radius: calc(5px * var(--scale-factor));
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 calc(2px * var(--scale-factor)) calc(5px * var(--scale-factor)) rgba(0,0,0,0.3);
            width: calc(90% * var(--scale-factor));
            max-width: calc(800px * var(--scale-factor));
            z-index: 10;
        }

        /* Style for the input field and buttons */
        #thoughtInput {
            width: var(--input-width); /* Larger input box */
            padding: calc(5px * var(--scale-factor));
            margin-right: calc(10px * var(--scale-factor));
            border: 1px solid #ccc;
            border-radius: calc(3px * var(--scale-factor));
            font-size: calc(16px * var(--scale-factor));
        }

        /* Utility class to hide elements */
        .hidden {
            display: none;
        }


        /* Unified button styles */
        .control-button {
            padding: calc(5px * var(--scale-factor)) calc(10px * var(--scale-factor));
            border: none;
            color: white;
            border-radius: calc(3px * var(--scale-factor));
            cursor: pointer;
            margin: 0; /* Removed individual margin */
            background-color: #6a11cb; /* Solid color background */
            box-shadow: 0 calc(2px * var(--scale-factor)) calc(5px * var(--scale-factor)) rgba(0,0,0,0.2);
            transition: background-color 0.3s;
            position: relative;
            font-size: calc(16px * var(--scale-factor));
            text-align: center;
            flex: 1 1 auto;
            width: var(--button-width); /* Smaller button width */
        }

        .control-button:not(:last-child) {
            margin-right: calc(5px * var(--scale-factor)); /* Small spacing between buttons */
        }

        .control-button:hover {
            background-color: #2575fc; /* Slightly different color on hover */
        }

        /* Custom tooltip styles */
        .control-button::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(-35px * var(--scale-factor));
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: calc(5px * var(--scale-factor)) calc(8px * var(--scale-factor));
            border-radius: calc(3px * var(--scale-factor));
            font-size: calc(12px * var(--scale-factor));
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 200;
        }

        .control-button:hover::after {
            opacity: 1;
        }

        /* Style for the thought bubbles */
        /* Style for bubbles */
        .bubble {
            position: absolute;
            border-radius: 50%;
            background-color: #87ceeb;
            color: #fff;
            width: calc(120px * var(--scale-factor));
            height: calc(120px * var(--scale-factor));
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            cursor: grab; /* Changed to grab for dragging */
            user-select: none;
            box-sizing: border-box;
            padding: calc(10px * var(--scale-factor));
            overflow-wrap: break-word;
            word-break: break-word;
            hyphens: auto;
            overflow: hidden; /* Hide overflow */
            box-shadow: 0 calc(2px * var(--scale-factor)) calc(5px * var(--scale-factor)) rgba(0,0,0,0.3);
            transition: box-shadow 0.3s, background-color 0.3s, opacity 0.3s;
            z-index: 10; /* Ensure bubbles are above the connection lines */
            font-size: calc(16px * var(--scale-factor));
            line-height: 1.2;
            opacity: 1;
            touch-action: none;
            pointer-events: auto;
        }

        /* Glow effect for selected bubble */
        .bubble.selected:not(.highlighted) {
            box-shadow: 0 0 calc(10px * var(--scale-factor)) calc(5px * var(--scale-factor)) rgba(255, 215, 0, 0.8);
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        /* Short red glow for highlighted bubble */
        .bubble.highlighted:not(.selected) {
            box-shadow: 0 0 calc(10px * var(--scale-factor)) calc(5px * var(--scale-factor)) rgba(255, 0, 0, 0.8);
        }

        /* Enhanced red glow for selected highlighted bubble */
        .bubble.highlighted.selected {
            box-shadow: 0 0 calc(30px * var(--scale-factor)) calc(15px * var(--scale-factor)) rgba(255, 0, 0, 0.8);
        }

        /* Outline for connected bubbles */
        .bubble.connected {
            /* border: calc(3px * var(--scale-factor)) solid gray; */
            border: calc(3px * var(--scale-factor)) solid black;
        }

        /* Style for the connection lines */
        .connection {
            /* stroke and marker-end are now set directly via JavaScript */
            cursor: pointer;
            pointer-events: auto; /* Allow lines to receive mouse events */
            stroke-linecap: round; /* Smooth line ends */
            /* transition: stroke 0.3s, stroke-width 0.3s, stroke-opacity 0.3s; */
            stroke: black;
            stroke-width: calc(3px * var(--scale-factor));
            stroke-opacity: 1;
        }

        .connection:hover {
            /* stroke-width: calc(3px * 1.5 * var(--scale-factor)); */
            stroke: gray
        }

        /* Cursor for draggable */
        .bubble.dragging {
            cursor: grabbing;
        }


        /* Adjusted z-index to make bubbles above connections */
        #connectionLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2; /* Increased z-index to ensure visibility */
            pointer-events: none; /* Allow clicks to pass through */
            /* Temporary background for debugging */
            /* background-color: rgba(255, 0, 0, 0.5);  */
        }

        /* Container for control buttons */
        #controlButtons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            width: calc(90% * var(--scale-factor));
            max-width: calc(800px * var(--scale-factor));
            gap: calc(5px * var(--scale-factor)); /* Small spacing between buttons */
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 400;
            background-color: rgba(255, 255, 255, 0.95);
            padding: calc(20px * var(--scale-factor)) calc(30px * var(--scale-factor));
            border-radius:  calc(10px * var(--scale-factor));
            box-shadow: 0 calc(5px * var(--scale-factor)) calc(10px * var(--scale-factor)) rgba(0,0,0,0.3);
            text-align: left;
            pointer-events: auto;  
            width: calc(500px * var(--scale-factor)); 
            line-height: 1.5;



            /* position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 15; 
            cursor: default;
            transition: opacity 0.3s; */
        }            

        /* Style for shortcuts summary */
        #shortcuts {
            display: none; /* Hidden by default */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 300; /* Higher z-index to overlay above all */
            font-size: calc(14px * var(--scale-factor));
            color: #333;
            background-color: rgba(255, 255, 255, 0.95);
            padding: calc(20px * var(--scale-factor)) calc(30px * var(--scale-factor));
            border-radius: calc(10px * var(--scale-factor));
            box-shadow: 0 calc(5px * var(--scale-factor)) calc(10px * var(--scale-factor)) rgba(0,0,0,0.3);
            text-align: left;
            pointer-events: auto; /* Allow interaction when visible */
        }

        /* Style for boxed letters in shortcuts */
        .shortcut-key {
            display: inline-block;
            width: calc(50px * var(--scale-factor));
            text-align: center;
            padding: calc(2px * var(--scale-factor)) 0;
            margin-right: calc(5px * var(--scale-factor));
            border: 1px solid #333;
            border-radius: calc(3px * var(--scale-factor));
            background-color: #eee;
            font-weight: bold;
            font-size: calc(12px * var(--scale-factor));
        }


        /* Style for Help Prompt */
        #helpPrompt {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.1);
            color: #fff;
            padding: calc(10px * var(--scale-factor)) calc(20px * var(--scale-factor));
            border-radius: calc(5px * var(--scale-factor));
            font-size: calc(14px * var(--scale-factor));
            z-index: 15; /* Ensure it's above other elements like bubbles */
            display: flex;
            gap: calc(20px * var(--scale-factor));
            pointer-events: none; /* Allow clicks to pass through */
            opacity: 1;
            transition: opacity 0.3s;
        }

        /* Tooltip styles for bubbles */
        .tooltip {
            max-width: calc(200px * var(--scale-factor));
            word-wrap: break-word;
        }

        /* Styles for the capture container */
        #captureContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* Lower z-index to allow interaction with mainContainer */
            overflow: hidden; 
            pointer-events: none; /* Allow pointer events to pass through */
            /* background-color: rgba(0,255,0,0.1); Temporary background for debugging */
        }

        /* Mobile Mode Adjustments */
        .mobile-mode #controlButtons {
            flex-wrap: wrap;
            gap: calc(5px * var(--scale-factor));
        }

        .mobile-mode .control-button {
            flex: 1 1 calc(45% - calc(5px * var(--scale-factor))); /* 2 buttons per row */
            max-width: calc(200px * var(--scale-factor)); /* Adjust button max width */
        }

        .mobile-mode #title {
            font-size: calc(24px * var(--scale-factor) * 0.65); /* Reduce font size to 65% */
        }

        .mobile-mode #saveButton {
            display: none;
        }

        .mobile-mode #inputArea {
            /* Maintain horizontal alignment */
            flex-direction: row;
            align-items: center;
            z-index: 10;
        }

        .mobile-mode #addThoughtButton {
            margin-left: calc(10px * var(--scale-factor));
            flex: 0 0 auto;
            width: calc(100px * var(--scale-factor)); /* Smaller button width */
            padding: calc(5px * var(--scale-factor)) calc(8px * var(--scale-factor)); /* Smaller padding */
        }

        #bubbleContainer {
            pointer-events: auto;
        }

        /* Ensure all main elements have equal vertical spacing */
        #mainContainer > * {
            /* Already managed by gap in flex container */
        }

        /* Ensure elements are centered */
        #mainContainer {
            left: 50%;
            transform: translateX(-50%);
        }

        /* Prevent #shortcuts from blocking interactions when hidden */
        #shortcuts.hidden {
            display: none;
            pointer-events: none;
        }

        #shortcuts.visible {
            display: block;
            pointer-events: auto;
        }
    </style>
</head>
<body>
    <!-- Main Container for Equal Spacing -->
    <div id="mainContainer">
        <!-- Title -->
        <div id="title">Floating Thought Bubbles Connect</div>

        <!-- Credits and Version -->
        <div id="credits">
            Made by Neil Kim<br>
            Latest Version: <!-- Latest version timestamp will be inserted here -->
        </div>

        <!-- Input area for adding thoughts -->
        <div id="inputArea">
            <input type="text" id="thoughtInput" placeholder="Enter your thought">
            <button id="addThoughtButton" class="control-button" data-tooltip="Turn your text into a thought bubble">Add Thought</button>
        </div>

        <!-- Buttons for controls -->
        <div id="controlButtons">
            <button id="randomizeButton" class="control-button" data-tooltip="Randomize the positions of the bubbles">Randomize Locations</button>
            <button id="saveButton" class="control-button" data-tooltip="Save the current view as a PNG image">Save to PNG</button>
            <button id="highlightButton" class="control-button" data-tooltip="Highlight or dehighlight selected bubbles">Highlight/Dehighlight Selected</button>
            <button id="zoomButton" class="control-button" data-tooltip="Zoom out or in">Zoom Out/In</button>
            <button id="modeToggleButton" class="control-button" data-tooltip="Toggle between mobile and desktop mode">Mobile Mode</button>
        </div>
    </div>

    <!-- Container for capturing bubbles and connections -->
    <div id="captureContainer">
        <!-- SVG layer for drawing connection lines -->
        <svg id="connectionLayer" width="100%" height="100%">
            <defs>
                <marker id="arrowhead-black" markerWidth="10" markerHeight="7"
                        refX="10" refY="3.5" orient="auto" markerUnits="strokeWidth">
                    <polygon points="0 0, 10 3.5, 0 7" fill="black"/>
                </marker>

                <marker id="arrowhead-gray" markerWidth="10" markerHeight="7"
                        refX="10" refY="3.5" orient="auto" markerUnits="strokeWidth">
                    <polygon points="0 0, 10 3.5, 0 7" fill="gray"/>
                </marker>
            </defs>
        </svg>

        <!-- Container for bubbles -->
        <div id="bubbleContainer"></div>
    </div>


    <div id="instructions" class="hidden">
        <h2>Instructions: (press "I" to close) </h2>
        <ul>
        <li>Click a bubble and then another to connect them.</li>
        <li>Click on connection arrows to remove connections.</li>
        <li>Deletion and modification of bubbles are intentionally left out as my intention is to keep all train of thoughts, including mistakes.</li>
        <li>Therefore, if you need to correct something, make a new bubble and connect it to the one you want to correct.</li>
        </ul>
    </div>


    <!-- Shortcut Summary (hidden by default) -->
    <div id="shortcuts" class="hidden">
        <p><strong>Shortcuts:</strong> (press "?" to close) <br>
            <span class="shortcut-key">i</span> - Focus Input<br>
            <span class="shortcut-key">s</span> - Randomize Locations<br>
            <span class="shortcut-key">v</span> - Save to PNG<br>
            <span class="shortcut-key">m</span> - Toggle Mobile/Desktop Mode<br>
            <span class="shortcut-key">I</span> - Show/Hide Instructions<br>
            <span class="shortcut-key">?</span> - Show/Hide Shortcuts<br>
            <span class="shortcut-key">F5</span> - Restart <br>
            <span class="shortcut-key">Esc</span> - Defocus Input<br>
            <span class="shortcut-key">Space</span> - Play/Pause Animation
        </p>
    </div>


    <!-- Help Prompt Area -->
    <div id="helpPrompt">
        <span class="instructions-text">Press "I" for instructions</span>
        <span class="shortcut-text">Press "?" for shortcuts</span>
    </div>

    <!-- Include html2canvas library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <script>
        let isPaused = false;
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM fully loaded and parsed.');

            // Arrays to store bubbles and connections
            let bubbles = [];
            let connections = [];
            let selectedBubbles = [];

            // Variables to control scaling
            let isZoomedOut = false;
            let isMobileMode = false;

            // Function to create a connection line
            function createConnection(b1, b2) {

                // Check if both bubbles exist
                if (!b1 || !b2) {
                    console.error('One or both bubbles are undefined:', b1, b2);
                    return;
                }

                // Ensure bubbles have DOM elements
                if (!b1.element || !b2.element) {
                    console.error('One or both bubbles are missing DOM elements:', b1, b2);
                    return;
                }

                // // Calculate the center positions of both bubbles
                // let x1 = b1.offsetLeft + (b1.offsetWidth / 2);
                // let y1 = b1.offsetTop + (b1.offsetHeight / 2);
                // let x2 = b2.offsetLeft + (b2.offsetWidth / 2);
                // let y2 = b2.offsetTop + (b2.offsetHeight / 2);

                // Get the bounding rectangles of both bubbles
                let rect1 = b1.element.getBoundingClientRect();
                let rect2 = b2.element.getBoundingClientRect();

                // Calculate centers
                let x1 = rect1.left + rect1.width / 2;
                let y1 = rect1.top + rect1.height / 2;
                let x2 = rect2.left + rect2.width / 2;
                let y2 = rect2.top + rect2.height / 2;

                // // Check if positions are valid numbers
                // if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2)) {
                //     console.error('Invalid positions for connection:', { x1, y1, x2, y2 });
                //     return;
                // }

                let line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', b1.offsetLeft + b1.offsetWidth / 2);
                line.setAttribute('y1', b1.offsetTop + b1.offsetHeight / 2);
                line.setAttribute('x2', b2.offsetLeft + b2.offsetWidth / 2);
                line.setAttribute('y2', b2.offsetTop + b2.offsetHeight / 2);
                line.setAttribute('stroke', 'black');
                line.setAttribute('stroke-width', '3');
                line.setAttribute('marker-end', 'url(#arrowhead)');

                // Append the line to the SVG layer.
                connectionLayer.appendChild(line);
                console.log(`Connection line added between ${b1.text} and ${b2.text}.`);
            }

            // Function to generate colors from a gradient colormap
            function getColorFromGradient(index, total) {
                let ratio = index / (total || 1);
                let hue = 200 + (ratio * 160); // Adjust hue between 200 and 360 degrees
                let saturation = 70; // Consistent saturation
                let lightness = 60; // Consistent lightness
                return 'hsl(' + hue + ', ' + saturation + '%, ' + lightness + '%)';
            }

            // Define the drag threshold
            const dragThreshold = 10; // Pixels

            // Bubble class representing each thought bubble
            class Bubble {
                constructor(text) {
                    this.text = text;
                    this.element = document.createElement('div');
                    this.element.className = 'bubble';

                    // Assign a color from the gradient colormap
                    this.color = getColorFromGradient(bubbles.length, 20); // Assuming a max of 20 bubbles
                    this.element.style.backgroundColor = this.color;

                    // Set the text content
                    this.setText(text);

                    // Add to the bubble container
                    document.getElementById('bubbleContainer').appendChild(this.element);

                    // Set initial position
                    this.setPosition();

                    // Set initial velocities to zero
                    this.vx = 0;
                    this.vy = 0;

                    // Apply initial position
                    this.updatePosition();

                    // this.addEventListeners();

                    // Event listener for showing full text on hover
                    this.element.addEventListener('mouseenter', (e) => {
                        this.showTooltip();
                    });

                    this.element.addEventListener('mouseleave', (e) => {
                        this.hideTooltip();
                    });

                    // Event listener to cancel selection with right-click
                    this.element.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        this.cancelSelection();
                    });

                    // Event listeners for dragging
                    this.isDragging = false;
                    this.dragOffsetX = 0;
                    this.dragOffsetY = 0;

                    this.element.addEventListener('mousedown', (e) => {
                        if (e.button === 0) { // Only left mouse button
                            e.stopPropagation();
                            this.isDragging = true;

                            let rect = this.element.getBoundingClientRect();
                            let offsetX = e.clientX - rect.left;
                            let offsetY = e.clientY - rect.top;

                            this.dragOffsetX = offsetX;
                            this.dragOffsetY = offsetY;
                            this.element.classList.add('dragging');

                            // Store initial mouse position for drag threshold
                            this.startX = e.clientX;
                            this.startY = e.clientY;
                        }
                    });

                    document.addEventListener('mousemove', (e) => {
                        if (this.isDragging) {
                            this.x = e.clientX - this.dragOffsetX;
                            this.y = e.clientY - this.dragOffsetY;

                            // Prevent dragging into forbidden area
                            this.y = Math.max(this.y, minBubbleY);
                            this.y = Math.min(this.y, maxBubbleY - this.element.offsetHeight); // Adjust for bubble height

                            this.vx = 0;
                            this.vy = 0;
                            this.updatePosition();
                        }
                    });


                    document.addEventListener('mouseup', (e) => {
                        if (this.isDragging) {
                            this.isDragging = false;
                            this.element.classList.remove('dragging');

                            // Calculate total movement during drag
                            let deltaX = e.clientX - this.startX;
                            let deltaY = e.clientY - this.startY;
                            let distanceMoved = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                            if (distanceMoved < dragThreshold) {
                                // Considered a click
                                this.select();
                            }
                        }
                    });

                    // Touch support for mobile devices
                    this.element.addEventListener('touchstart', (e) => {
                        this.isDragging = true;
                        const touch = e.touches[0];
                        startX = touch.clientX;
                        startY = touch.clientY;
                        initialLeft = parseInt(this.element.style.left, 10);
                        initialTop = parseInt(this.element.style.top, 10);
                        this.element.style.cursor = 'grabbing';
                        e.preventDefault();
                    }, { passive: false });

                    document.addEventListener('touchmove', (e) => {
                        if (!this.isDragging) return;
                        const touch = e.touches[0];
                        let deltaX = touch.clientX - startX;
                        let deltaY = touch.clientY - startY;
                        this.element.style.left = `${initialLeft + deltaX}px`;
                        this.element.style.top = `${initialTop + deltaY}px`;
                        updateConnections(); // Update connections on move
                    }, {passive: false});

                    document.addEventListener('touchend', () => {
                        if (this.isDragging) {
                            this.isDragging = false;
                            this.element.style.cursor = 'grab';
                        }
                    }, { passive: false });

                    this.selected = false;
                    this.connectedBubbles = [];
                    this.highlighted = false;

                    console.log(`Bubble "${this.text}" initialized at position (${this.x}, ${this.y}).`);
 
                
                    // // Event listener for selecting bubbles
                    // this.element.addEventListener('click', () => {
                    //     this.select();
                    // });
                }

                // Set text content
                setText(text) {
                    this.text = text;
                    this.element.innerText = this.text;
                }

                // Show tooltip with full text
                showTooltip() {
                    this.tooltip = document.createElement('div');
                    this.tooltip.className = 'tooltip';
                    this.tooltip.innerText = this.text;
                    document.body.appendChild(this.tooltip);

                    let rect = this.element.getBoundingClientRect();
                    this.tooltip.style.position = 'absolute';
                    this.tooltip.style.left = rect.left + 'px';
                    this.tooltip.style.top = (rect.top - 30) + 'px';
                    this.tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                    this.tooltip.style.color = '#fff';
                    this.tooltip.style.padding = '5px 8px';
                    this.tooltip.style.borderRadius = '3px';
                    this.tooltip.style.fontSize = '12px';
                    this.tooltip.style.whiteSpace = 'normal';
                    this.tooltip.style.maxWidth = '200px';
                    this.tooltip.style.wordWrap = 'break-word';
                    this.tooltip.style.pointerEvents = 'none';
                    this.tooltip.style.zIndex = 100;
                }

                // Hide tooltip
                hideTooltip() {
                    if (this.tooltip) {
                        document.body.removeChild(this.tooltip);
                        this.tooltip = null;
                    }
                }

                // Set initial position, avoiding overlap with existing bubbles and forbidden area
                setPosition() {
                    let maxAttempts = 100;
                    let attempt = 0;
                    let placed = false;

                    while (!placed && attempt < maxAttempts) {
                        attempt++;
                        // Random position within the allowed bounds
                        this.x = Math.random() * (window.innerWidth - this.element.offsetWidth);
                        this.y = Math.random() * (maxBubbleY - minBubbleY - this.element.offsetHeight) + minBubbleY;

                        // Check for overlap with existing bubbles
                        placed = true;
                        for (let otherBubble of bubbles) {
                            let dx = this.x - otherBubble.x;
                            let dy = this.y - otherBubble.y;
                            let distance = Math.sqrt(dx * dx + dy * dy);
                            let minDistance = desiredDistance; // Use the same desired distance as for connected bubbles
                            if (distance < minDistance) {
                                placed = false;
                                break;
                            }
                        }
                    }

                    if (!placed) {
                        // If couldn't find a non-overlapping position, place at center with small random offset
                        this.x = window.innerWidth / 2 - this.element.offsetWidth / 2 + (Math.random() - 0.5) * 200;
                        this.y = (maxBubbleY + minBubbleY) / 2 - this.element.offsetHeight / 2 + (Math.random() - 0.5) * 200;
                        // Ensure it's within allowed bounds
                        this.y = Math.max(this.y, minBubbleY);
                        this.y = Math.min(this.y, maxBubbleY - this.element.offsetHeight);
                    }
                }

                // Update position and handle interactions
                update() {
                    // Initialize forces
                    let fx = 0;
                    let fy = 0;

                    // Repulsion from other bubbles
                    bubbles.forEach(otherBubble => {
                        if (otherBubble !== this) {
                            let dx = this.x - otherBubble.x;
                            let dy = this.y - otherBubble.y;
                            let distance = Math.sqrt(dx * dx + dy * dy);
                            let minDistance = desiredDistance; // Use the same desired distance as for connected bubbles
                            if (distance < minDistance && distance > 0) {
                                let overlap = minDistance - distance;
                                let force = overlap * 0.1; // Repulsion strength
                                fx += (dx / distance) * force;
                                fy += (dy / distance) * force;
                            }
                        }
                    });

                    // Attraction to connected bubbles
                    this.connectedBubbles.forEach(otherBubble => {
                        let dx = otherBubble.x - this.x;
                        let dy = otherBubble.y - this.y;
                        let distance = Math.sqrt(dx * dx + dy * dy);
                        let desiredDist = desiredDistance; // Desired length of the spring
                        if (distance > 0) {
                            let force = 0.05 * (distance - desiredDist); // Attraction strength
                            fx += (dx / distance) * force;
                            fy += (dy / distance) * force;
                        }
                    });

                    // Centering force
                    let centerX = window.innerWidth / 2 - this.element.offsetWidth / 2;
                    let centerY = (maxBubbleY + minBubbleY) / 2 - this.element.offsetHeight / 2;
                    let dxCenter = centerX - this.x;
                    let dyCenter = centerY - this.y;
                    let centeringForce = 0.005; // Reduced centering force
                    fx += dxCenter * centeringForce;
                    fy += dyCenter * centeringForce;

                    // Update velocities
                    const damping = 0.7; // Increased damping
                    this.vx = (this.vx + fx) * damping;
                    this.vy = (this.vy + fy) * damping;

                    // // If velocities are very small, set them to zero
                    // if (Math.abs(this.vx) < 0.05) this.vx = 0;
                    // if (Math.abs(this.vy) < 0.05) this.vy = 0;

                    // Update positions
                    this.x += this.vx;
                    this.y += this.vy;

                    // Prevent moving into forbidden area
                    this.y = Math.max(this.y, minBubbleY);
                    this.y = Math.min(this.y, maxBubbleY - this.element.offsetHeight);

                    // Apply the updated position
                    this.updatePosition();
                }

                // Update the bubble's CSS position
                updatePosition() {
                    this.element.style.left = this.x + 'px';
                    this.element.style.top = this.y + 'px';
                }

                // Handle bubble selection
                select() {
                    console.log('Bubble selected:', this.text);
                    if (this.selected) {
                        // Deselect the bubble
                        this.selected = false;
                        this.element.classList.remove('selected');
                        let index = selectedBubbles.indexOf(this);
                        if (index > -1) {
                            selectedBubbles.splice(index, 1);
                        }
                    } else {
                        // Select the bubble
                        this.selected = true;
                        this.element.classList.add('selected');
                        selectedBubbles.push(this);

                        if (selectedBubbles.length === 2) {
                            let bubble1 = selectedBubbles[0];
                            let bubble2 = selectedBubbles[1];

                            // Prevent connecting the same bubble to itself
                            if (bubble1 === bubble2) {
                                console.warn('Attempted to connect a bubble to itself. Connection aborted.');
                                bubble1.selected = false;
                                bubble1.element.classList.remove('selected');
                                selectedBubbles = [];
                                return;
                            }

                            console.log('Connecting bubbles:', bubble1.text, bubble2.text);

                            // Prevent duplicate connections
                            if (!connections.some(conn => 
                                (conn.bubble1 === bubble1 && conn.bubble2 === bubble2) || 
                                (conn.bubble1 === bubble2 && conn.bubble2 === bubble1)
                            )) {
                                let connection = new Connection(bubble1, bubble2);
                                connections.push(connection);

                                // Add each bubble to the other's connectedBubbles list
                                bubble1.connectedBubbles.push(bubble2);
                                bubble2.connectedBubbles.push(bubble1);

                                // Add connected class to bubbles
                                bubble1.element.classList.add('connected');
                                bubble2.element.classList.add('connected');
                            }

                            // Add a connection between Bubble 1 and Bubble 2
                            createConnection(bubble1, bubble2);

                            // Clear selection
                            bubble1.selected = false;
                            bubble2.selected = false;
                            bubble1.element.classList.remove('selected');
                            bubble2.element.classList.remove('selected');

                            // Clear the selectedBubbles array
                            selectedBubbles = [];

                            // Ensure highlighted bubbles revert to short red glow
                            if (bubble1.highlighted) {
                                bubble1.element.classList.add('highlighted');
                            }
                            if (bubble2.highlighted) {
                                bubble2.element.classList.add('highlighted');
                            }
                        }
                    }
                }

                // Cancel selection
                cancelSelection() {
                    if (this.selected) {
                        this.selected = false;
                        this.element.classList.remove('selected');
                        let index = selectedBubbles.indexOf(this);
                        if (index > -1) {
                            selectedBubbles.splice(index, 1);
                        }
                    }
                }

                // Toggle highlight
                toggleHighlight() {
                    if (this.highlighted) {
                        // Dehighlight and deselect
                        this.highlighted = false;
                        this.element.classList.remove('highlighted');
                        if (this.selected) {
                            this.selected = false;
                            this.element.classList.remove('selected');
                            let index = selectedBubbles.indexOf(this);
                            if (index > -1) {
                                selectedBubbles.splice(index, 1);
                            }
                        }
                    } else {
                        // Highlight and deselect
                        this.highlighted = true;
                        this.element.classList.add('highlighted');
                        if (this.selected) {
                            this.selected = false;
                            this.element.classList.remove('selected');
                            let index = selectedBubbles.indexOf(this);
                            if (index > -1) {
                                selectedBubbles.splice(index, 1);
                            }
                        }
                    }
                }

                // Remove the bubble from the document
                remove() {
                    this.hideTooltip();
                    document.getElementById('bubbleContainer').removeChild(this.element);
                }
            }

            // Global variable for desired distance
            let desiredDistance = null;

            // Connection class representing the line between two bubbles
            class Connection {
                constructor(bubble1, bubble2) {
                    this.bubble1 = bubble1;
                    this.bubble2 = bubble2;

                    // Create a line element in the SVG layer
                    this.line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    this.line.setAttribute('class', 'connection');
                    this.line.setAttribute('stroke', 'black'); // Set a distinct color
                    this.line.setAttribute('stroke-width', `${3 * getScaleFactor()}px`); // Consistent with CSS
                    this.line.setAttribute('marker-end', 'url(#arrowhead-black)'); // Set marker directly

                    document.getElementById('connectionLayer').appendChild(this.line);
                    console.log(`Connection created between "${bubble1.text}" and "${bubble2.text}"`);

                    // Event listener for clicking on the connection
                    this.line.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.disconnect();
                    });

                    // Event listeners for hover to change arrowhead color and pause animation
                    this.line.addEventListener('mouseenter', () => {
                        console.log(`Connection hovered: "${bubble1.text}" to "${bubble2.text}"`);
                        this.line.setAttribute('marker-end', 'url(#arrowhead-gray)');
                        isPaused = true;
                        console.log('Animation paused on mouseenter.');
                    });

                    this.line.addEventListener('mouseleave', () => {
                        console.log(`Connection unhovered: "${bubble1.text}" to "${bubble2.text}"`);
                        this.line.setAttribute('marker-end', 'url(#arrowhead-black)');

                        // Resume the animation
                        isPaused = false;
                        console.log('Animation resumed after hover.');
                    });
                }

                // Update the line's position to match the bubbles
                update() {
                    // Get centers of the bubbles
                    let x1 = this.bubble1.x + this.bubble1.element.offsetWidth / 2;
                    let y1 = this.bubble1.y + this.bubble1.element.offsetHeight / 2;
                    let x2 = this.bubble2.x + this.bubble2.element.offsetWidth / 2;
                    let y2 = this.bubble2.y + this.bubble2.element.offsetHeight / 2;

                    // Compute the direction vector
                    let dx = x2 - x1;
                    let dy = y2 - y1;
                    let distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance === 0) {
                        // Prevent division by zero
                        console.warn('Zero distance between bubbles. Skipping update.');
                        return;
                    }

                    // Normalize the direction vector
                    let dxNorm = dx / distance;
                    let dyNorm = dy / distance;

                    // Calculate radius (assuming circles)
                    let radius1 = this.bubble1.element.offsetWidth / 2;
                    let radius2 = this.bubble2.element.offsetWidth / 2;

                    // Adjust for arrowhead size
                    let arrowheadSize = 10 * getScaleFactor(); // Adjust as needed

                    // Calculate start and end points of the line
                    let startX = x1 + dxNorm * radius1;
                    let startY = y1 + dyNorm * radius1;

                    let endOffset = -13;
                    // let endOffset = 0;
                    let endX = x2 - dxNorm * (radius2 + arrowheadSize + endOffset);
                    let endY = y2 - dyNorm * (radius2 + arrowheadSize + endOffset);

                    // Update the line
                    this.line.setAttribute('x1', startX);
                    this.line.setAttribute('y1', startY);
                    this.line.setAttribute('x2', endX);
                    this.line.setAttribute('y2', endY);

                    console.log(`Connection updated: (${startX}, ${startY}) to (${endX}, ${endY})`);
                }

                // Remove the line from the SVG layer and disconnect bubbles
                disconnect() {
                    console.log('Disconnecting bubbles:', this.bubble1.text, this.bubble2.text);
                    this.remove();
                    connections = connections.filter(conn => conn !== this);
                    let index1 = this.bubble1.connectedBubbles.indexOf(this.bubble2);
                    if (index1 > -1) this.bubble1.connectedBubbles.splice(index1, 1);
                    let index2 = this.bubble2.connectedBubbles.indexOf(this.bubble1);
                    if (index2 > -1) this.bubble2.connectedBubbles.splice(index2, 1);

                    // Remove connected class if no other connections
                    if (this.bubble1.connectedBubbles.length === 0) {
                        this.bubble1.element.classList.remove('connected');
                    }
                    if (this.bubble2.connectedBubbles.length === 0) {
                        this.bubble2.element.classList.remove('connected');
                    }
                }

                remove() {
                    document.getElementById('connectionLayer').removeChild(this.line);
                }
            }

            // Function to find connected components
            function findConnectedComponents(bubbles) {
                let visited = new Set();
                let components = [];

                for (let bubble of bubbles) {
                    if (!visited.has(bubble)) {
                        let component = [];
                        let stack = [bubble];

                        while (stack.length > 0) {
                            let currentBubble = stack.pop();
                            if (!visited.has(currentBubble)) {
                                visited.add(currentBubble);
                                component.push(currentBubble);
                                for (let neighbor of currentBubble.connectedBubbles) {
                                    if (!visited.has(neighbor)) {
                                        stack.push(neighbor);
                                    }
                                }
                            }
                        }

                        components.push(component);
                    }
                }

                return components;
            }

            // Function to get the current scale factor from CSS variable
            function getScaleFactor() {
                return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-factor')) || 1;
            }

            // Calculate the minimum Y position for bubbles to prevent invasion of the buttons area
            let minBubbleY = calculateMinBubbleY();
            let maxBubbleY = calculateMaxBubbleY();

            function calculateMinBubbleY() {
                // Get the bottom position of the lowest element above the bubbles
                const mainContainer = document.getElementById('mainContainer');
                const rect = mainContainer.getBoundingClientRect();
                const padding = 10; // 10 pixels padding
                return rect.bottom + padding;
            }

            function calculateMaxBubbleY() {
                return window.innerHeight;
            }

            // Update minBubbleY and maxBubbleY when window resizes
            window.addEventListener('resize', () => {
                minBubbleY = calculateMinBubbleY();
                maxBubbleY = calculateMaxBubbleY();
                console.log('Window resized. Updated minBubbleY:', minBubbleY, 'maxBubbleY:', maxBubbleY);
            });

            // Animation loop to update bubbles and connections
            function animate() {
                if (!isPaused) {
                    // Update all bubbles
                    bubbles.forEach(bubble => {
                        bubble.update();
                    });

                    // Update all connections
                    connections.forEach(connection => {
                        connection.update();
                    });
                }

                // Continue animation
                requestAnimationFrame(animate);
            }

            // Start the animation loop
            animate();
            console.log('Animation loop started.');

            function addBubble(text) {
                // Calculate random positions within the allowed bounds
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const left = Math.floor(Math.random() * (viewportWidth - 140)) + 10; // Adjust based on bubble size
                const top = Math.floor(Math.random() * (maxBubbleY - minBubbleY - 140)) + minBubbleY; // Adjust based on bubble size and forbidden area

                let newBubble = new Bubble(text);
                newBubble.x = left;
                newBubble.y = top;
                newBubble.updatePosition(); // Apply the position

                bubbles.push(newBubble);

                console.log('New bubble added:', text, 'at position:', left, top);
                return newBubble;
            }

            // Event listener for adding a new thought bubble
            function addThought() {
                console.log('Add Thought button clicked.');
                let text = document.getElementById('thoughtInput').value;
                if (text.trim() !== '') {
                    console.log('Adding new bubble with text:', text);
                    let newBubble = addBubble(text);
                    // bubbles.push(bubble);
                    document.getElementById('thoughtInput').value = '';
                    document.getElementById('thoughtInput').focus();
                } else {
                    console.log('Input is empty. No bubble added.');
                }
            }

            // Ensure the "Add Thought" button has the correct event listener
            const addThoughtButton = document.getElementById('addThoughtButton');
            if (addThoughtButton) {
                addThoughtButton.addEventListener('click', addThought);
                console.log('"Add Thought" button event listener attached.');
            } else {
                console.error('Add Thought button not found!');
            }

            // Allow pressing Enter key to add thought
            const thoughtInput = document.getElementById('thoughtInput');
            if (thoughtInput) {
                thoughtInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        addThought();
                    }
                });
                console.log('Enter key event listener attached to thought input.');
            } else {
                console.error('Thought input field not found!');
            }

            // Define the desired distance based on bubble size
            function updateDesiredDistance() {
                // Assuming all bubbles have the same size
                let bubbleDiameter = 120 * getScaleFactor(); // Bubble width in pixels
                desiredDistance = bubbleDiameter + 50 * getScaleFactor(); // Bubble diameter plus 50 pixels
                console.log('Desired distance set to:', desiredDistance);
            }

            // Update desired distance on load and when scale changes
            updateDesiredDistance();

            // Randomize Locations functionality
            function randomizeLocations() {
                console.log('Randomizing bubble locations.');
                bubbles.forEach(bubble => {
                    // Fade out
                    bubble.element.style.opacity = 0;
                });
                setTimeout(() => {
                    bubbles.forEach(bubble => {
                        // Set new random positions
                        bubble.setPosition();
                        bubble.updatePosition();
                        // Fade in
                        bubble.element.style.opacity = 1;
                    });
                    console.log('Bubble locations randomized.');
                }, 300); // Wait 300ms for fade-out effect
            }

            const randomizeButton = document.getElementById('randomizeButton');
            if (randomizeButton) {
                randomizeButton.addEventListener('click', randomizeLocations);
                console.log('"Randomize Locations" button event listener attached.');
            } else {
                console.error('Randomize button not found!');
            }

            // Save to PNG functionality
            function saveToPNG() {
                console.log('Saving to PNG.');
                // Use html2canvas to capture the screenshot
                html2canvas(document.getElementById('captureContainer'), {
                    backgroundColor: null, // Preserve background transparency
                    useCORS: true,
                    allowTaint: true,
                    scale: window.devicePixelRatio * 2 * getScaleFactor(), // Increased resolution
                }).then(canvas => {
                    // Create a link to download the image
                    let link = document.createElement('a');
                    link.download = 'thought_bubbles.png';
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    console.log('PNG saved successfully.');
                }).catch(err => {
                    console.error('Error saving to PNG:', err);
                });
            }

            const saveButton = document.getElementById('saveButton');
            if (saveButton) {
                saveButton.addEventListener('click', saveToPNG);
                console.log('"Save to PNG" button event listener attached.');
            } else {
                console.error('Save button not found!');
            }

            // Highlight/Dehighlight functionality
            function toggleHighlight() {
                console.log('Toggling highlight on selected bubbles.');
                selectedBubbles.forEach(bubble => {
                    bubble.toggleHighlight();
                });
                // After toggling highlight, deselect all bubbles
                selectedBubbles.forEach(bubble => {
                    bubble.selected = false;
                    bubble.element.classList.remove('selected');
                });
                selectedBubbles = [];
            }

            const highlightButton = document.getElementById('highlightButton');
            if (highlightButton) {
                highlightButton.addEventListener('click', toggleHighlight);
                console.log('"Highlight/Dehighlight" button event listener attached.');
            } else {
                console.error('Highlight button not found!');
            }

            // Zoom In/Out functionality
            function toggleZoom() {
                console.log('Toggling zoom.');
                isZoomedOut = !isZoomedOut;

                if (isZoomedOut) {
                    document.documentElement.style.setProperty('--scale-factor', getScaleFactor() * 0.5);
                    document.getElementById('zoomButton').innerText = 'Zoom In';
                } else {
                    document.documentElement.style.setProperty('--scale-factor', isMobileMode ? 2.1 : 1);
                    document.getElementById('zoomButton').innerText = 'Zoom Out';
                }

                // Update min and max bubble Y positions
                minBubbleY = calculateMinBubbleY();
                maxBubbleY = calculateMaxBubbleY();

                // Update desired distance
                updateDesiredDistance();
                console.log('Zoom toggled. Scale factor updated.');
            }

            const zoomButton = document.getElementById('zoomButton');
            if (zoomButton) {
                zoomButton.addEventListener('click', toggleZoom);
                console.log('"Zoom In/Out" button event listener attached.');
            } else {
                console.error('Zoom button not found!');
            }

            // Mobile/Desktop mode toggle functionality
            function toggleMode() {
                console.log('Toggling mobile/desktop mode.');
                isMobileMode = !isMobileMode;

                if (isMobileMode) {
                    document.documentElement.style.setProperty('--scale-factor', 2.1); // 210% scaling
                    document.getElementById('modeToggleButton').innerText = 'Desktop Mode';
                    // Hide save button
                    const saveBtn = document.getElementById('saveButton');
                    if (saveBtn) {
                        saveBtn.style.display = 'none';
                        console.log('Save button hidden for mobile mode.');
                    }
                    // Change "Add Thought" to "Add"
                    const addBtn = document.getElementById('addThoughtButton');
                    if (addBtn) {
                        addBtn.innerText = 'Add';
                        console.log('"Add Thought" button text changed to "Add" for mobile mode.');
                    }
                } else {
                    document.documentElement.style.setProperty('--scale-factor', 1);
                    document.getElementById('modeToggleButton').innerText = 'Mobile Mode';
                    // Show save button
                    const saveBtn = document.getElementById('saveButton');
                    if (saveBtn) {
                        saveBtn.style.display = 'inline-block';
                        console.log('Save button shown for desktop mode.');
                    }
                    // Change "Add" back to "Add Thought"
                    const addBtn = document.getElementById('addThoughtButton');
                    if (addBtn) {
                        addBtn.innerText = 'Add Thought';
                        console.log('"Add" button text changed back to "Add Thought" for desktop mode.');
                    }
                }

                // Update min and max bubble Y positions
                minBubbleY = calculateMinBubbleY();
                maxBubbleY = calculateMaxBubbleY();

                // Update desired distance
                updateDesiredDistance();
                console.log('Mode toggled. Scale factor and bubble positions updated.');
            }

            const modeToggleButton = document.getElementById('modeToggleButton');
            if (modeToggleButton) {
                modeToggleButton.addEventListener('click', toggleMode);
                console.log('"Mobile/Desktop Mode" button event listener attached.');
            } else {
                console.error('Mode Toggle button not found!');
            }

            // Toggle Instructions Display
            function toggleInstructions() {
                console.log('Toggling Instructions display.');
                const instructionsDiv = document.getElementById('instructions');
                if (instructionsDiv.classList.contains('hidden')) {
                    instructionsDiv.classList.remove('hidden');
                    instructionsDiv.classList.add('visible');
                    console.log('Instructions shown.');
                } else {
                    instructionsDiv.classList.remove('visible');
                    instructionsDiv.classList.add('hidden');
                    console.log('Instructions hidden.');
                }
            }

            // Toggle Shortcuts Display
            function toggleShortcuts() {
                console.log('Toggling shortcuts display.');
                const shortcutsDiv = document.getElementById('shortcuts');
                if (shortcutsDiv.classList.contains('hidden')) {
                    shortcutsDiv.classList.remove('hidden');
                    shortcutsDiv.classList.add('visible');
                    console.log('Shortcuts shown.');
                } else {
                    shortcutsDiv.classList.remove('visible');
                    shortcutsDiv.classList.add('hidden');
                    console.log('Shortcuts hidden.');
                }
            }

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    document.getElementById('thoughtInput').blur();
                    console.log('Shortcut: Defocus Input');
                }
                if (e.key == ' ') { // Spacebar
                    const activeElement = document.activeElement;
                    const isInputActive = activeElement && (
                        activeElement.tagName === 'INPUT' || 
                        activeElement.tagName === 'TEXTAREA' ||
                        activeElement.isContentEditable
                    )

                    if (!isInputActive) {
                        e.preventDefault();
                        isPaused = !isPaused;
                        if (isPaused) {
                            console.log('Animation paused via Space bar shortcut.');
                            mainContainer.classList.add('animation-paused'); // Optional: Visual indicator
                        } else {
                            console.log('Animation resumed via Space bar shortcut.');
                            mainContainer.classList.remove('animation-paused'); // Optional: Remove visual indicator
                        }
                    }
                }
                if (e.target !== document.getElementById('thoughtInput')) {
                    if (e.key === 'i') {
                        e.preventDefault();
                        document.getElementById('thoughtInput').focus();
                        console.log('Shortcut: Focus Input');
                    } else if (e.key === 's') {
                        e.preventDefault();
                        randomizeLocations();
                        console.log('Shortcut: Randomize Locations');
                    } else if (e.key === 'v') {
                        e.preventDefault();
                        saveToPNG();
                        console.log('Shortcut: Save to PNG');
                    } else if (e.key === 'm') {
                        e.preventDefault();
                        toggleMode();
                        console.log('Shortcut: Toggle Mobile/Desktop Mode');
                    } else if (e.key === '?') {
                        e.preventDefault();
                        toggleShortcuts();
                        console.log('Shortcut: Show/Hide Shortcuts');
                    } else if (e.key === 'I') {
                        e.preventDefault();
                        toggleInstructions();
                        console.log('Shortcut: Show/Hide Shortcuts');
                    }
                }
            });

            // Insert the latest version timestamp
            function insertVersionTimestamp() {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const timestamp = `${year}-${month}-${day}-${hours}:${minutes}`;
                document.getElementById('credits').innerHTML += ` ${timestamp}`;
                console.log('Version timestamp inserted:', timestamp);
            }

            insertVersionTimestamp();

            // Place cursor in the text edit box as default
            document.getElementById('thoughtInput').focus();
            console.log('Focus set to thought input.');

            // Ensure that when shortcuts are hidden, they don't block interactions
            const shortcutsDiv = document.getElementById('shortcuts');
            shortcutsDiv.addEventListener('click', (e) => {
                e.stopPropagation();
            });

            // Recalculate minBubbleY and maxBubbleY after everything is loaded
            minBubbleY = calculateMinBubbleY();
            maxBubbleY = calculateMaxBubbleY();
            console.log('Initial minBubbleY:', minBubbleY, 'maxBubbleY:', maxBubbleY);
        });
    </script>
</body>
</html>
